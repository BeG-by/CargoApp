{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _jsxFileName = \"D:\\\\projects\\\\cargo_app\\\\frontend\\\\src\\\\map\\\\markers-list.js\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport React, { useEffect, useState } from \"react\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport { ListItem } from \"material-ui/List\";\nimport List from \"@material-ui/core/List\";\nimport { API_KEY } from \"./abstract-map\";\nimport { countDistanceBetweenMarkers, pointsComparator } from \"./utils\";\nvar useStyles = makeStyles(function (theme) {\n  return {\n    root: {\n      width: 400,\n      height: 500,\n      overflow: 'auto',\n      backgroundColor: theme.palette.background.paper\n    }\n  };\n});\nexport default function ItemList(props) {\n  var _this = this;\n\n  var classes = useStyles();\n\n  var _useState = useState([]),\n      _useState2 = _slicedToArray(_useState, 2),\n      geocodedPoints = _useState2[0],\n      setGeocodedPoints = _useState2[1];\n\n  var _useState3 = useState(0),\n      _useState4 = _slicedToArray(_useState3, 2),\n      distance = _useState4[0],\n      setDistance = _useState4[1];\n\n  var handleRowClick = function handleRowClick(geocodedPoint) {\n    props.onRowClick(geocodedPoint.index);\n  };\n\n  var updateDistance = function updateDistance(points) {\n    setDistance(countDistanceBetweenMarkers(points) / 1000);\n  };\n\n  var isPointGeocoded = function isPointGeocoded(point) {\n    for (var _iterator = _createForOfIteratorHelperLoose(geocodedPoints), _step; !(_step = _iterator()).done;) {\n      var geocodedPoint = _step.value;\n\n      if (geocodedPoint.index === point.index) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  var geocodeNewPoint = function geocodeNewPoint(point) {\n    var geocodedPoint;\n    return _regeneratorRuntime.async(function geocodeNewPoint$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return _regeneratorRuntime.awrap(geocode(point.lat, point.lng));\n\n          case 2:\n            geocodedPoint = _context.sent;\n            _context.next = 5;\n            return _regeneratorRuntime.awrap(setGeocodedPoints(function (prevState) {\n              var points = prevState.slice();\n              points.push({\n                index: point.index,\n                geocodedPoint: geocodedPoint\n              });\n              return points;\n            }));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n\n  var geocodeNewPoints = function geocodeNewPoints(points) {\n    var _iterator2, _step2, point;\n\n    return _regeneratorRuntime.async(function geocodeNewPoints$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            for (_iterator2 = _createForOfIteratorHelperLoose(points); !(_step2 = _iterator2()).done;) {\n              point = _step2.value;\n\n              if (!isPointGeocoded(point)) {\n                geocodeNewPoint(point);\n              }\n            }\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n\n  var deleteGeocodePointByIndex = function deleteGeocodePointByIndex(index) {\n    return _regeneratorRuntime.async(function deleteGeocodePointByIndex$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return _regeneratorRuntime.awrap(setGeocodedPoints(function (prevState) {\n              var points = prevState.slice();\n              points.splice(index, 1);\n              return points;\n            }));\n\n          case 2:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  };\n\n  var deleteGeocodedPoint = function deleteGeocodedPoint(points) {\n    var isPointDeleted;\n\n    for (var i = 0; i < geocodedPoints.length; i++) {\n      isPointDeleted = true;\n\n      for (var _iterator3 = _createForOfIteratorHelperLoose(points), _step3; !(_step3 = _iterator3()).done;) {\n        var point = _step3.value;\n\n        if (geocodedPoints[i].index === point.index) {\n          isPointDeleted = false;\n          break;\n        }\n      }\n\n      if (isPointDeleted) {\n        deleteGeocodePointByIndex(i);\n        break;\n      }\n    }\n  };\n\n  var geocode = function geocode(lat, lng) {\n    var response;\n    return _regeneratorRuntime.async(function geocode$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            _context4.next = 3;\n            return _regeneratorRuntime.awrap(fetch(\"https://maps.googleapis.com/maps/api/geocode/json?latlng=\" + lat + \",\" + lng + \"&language=en&key=\" + API_KEY));\n\n          case 3:\n            response = _context4.sent;\n            _context4.next = 6;\n            return _regeneratorRuntime.awrap(response.json());\n\n          case 6:\n            response = _context4.sent;\n            return _context4.abrupt(\"return\", response.results[0].formatted_address);\n\n          case 10:\n            _context4.prev = 10;\n            _context4.t0 = _context4[\"catch\"](0);\n            console.error(\"Cannot geocode\");\n            return _context4.abrupt(\"return\", \"Unrecognized place\");\n\n          case 14:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, [[0, 10]], Promise);\n  };\n\n  useEffect(function () {\n    if (props.items.length > geocodedPoints.length) {\n      geocodeNewPoints(props.items);\n    } else if (props.items.length < geocodedPoints.length) {\n      deleteGeocodedPoint(props.items);\n    }\n\n    updateDistance(props.items);\n  }, [props.items.length]);\n  return React.createElement(List, {\n    className: classes.root,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 103,\n      columnNumber: 9\n    }\n  }, React.createElement(\"div\", {\n    align: \"center\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 104,\n      columnNumber: 13\n    }\n  }, React.createElement(\"h3\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 105,\n      columnNumber: 17\n    }\n  }, props.listName + (\"  [\" + distance.toFixed(3) + \" km]\"))), geocodedPoints.sort(pointsComparator).map(function (point, key) {\n    return React.createElement(ListItem, {\n      align: \"left\",\n      primaryText: \"[\" + (key + 1) + \"] \" + point.geocodedPoint,\n      key: key,\n      onClick: function onClick() {\n        return handleRowClick(point);\n      },\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 109,\n        columnNumber: 21\n      }\n    });\n  }));\n}","map":{"version":3,"sources":["D:/projects/cargo_app/frontend/src/map/markers-list.js"],"names":["React","useEffect","useState","makeStyles","ListItem","List","API_KEY","countDistanceBetweenMarkers","pointsComparator","useStyles","theme","root","width","height","overflow","backgroundColor","palette","background","paper","ItemList","props","classes","geocodedPoints","setGeocodedPoints","distance","setDistance","handleRowClick","geocodedPoint","onRowClick","index","updateDistance","points","isPointGeocoded","point","geocodeNewPoint","geocode","lat","lng","prevState","slice","push","geocodeNewPoints","deleteGeocodePointByIndex","splice","deleteGeocodedPoint","isPointDeleted","i","length","fetch","response","json","results","formatted_address","console","error","items","listName","toFixed","sort","map","key"],"mappings":"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","sourcesContent":["import React, {useEffect, useState} from \"react\";\r\nimport {makeStyles} from \"@material-ui/core/styles\";\r\nimport {ListItem} from \"material-ui/List\";\r\nimport List from \"@material-ui/core/List\";\r\nimport {API_KEY} from \"./abstract-map\";\r\nimport {countDistanceBetweenMarkers, pointsComparator} from \"./utils\";\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n    root: {\r\n        width: 400,\r\n        height: 500,\r\n        overflow: 'auto',\r\n        backgroundColor: theme.palette.background.paper,\r\n    },\r\n}));\r\n\r\nexport default function ItemList(props) {\r\n    const classes = useStyles();\r\n    const [geocodedPoints, setGeocodedPoints] = useState([]);\r\n    const [distance, setDistance] = useState(0);\r\n\r\n    const handleRowClick = (geocodedPoint) => {\r\n        props.onRowClick(geocodedPoint.index);\r\n    };\r\n\r\n    const updateDistance = (points) => {\r\n        setDistance(countDistanceBetweenMarkers(points) / 1000);\r\n    }\r\n\r\n\r\n    const isPointGeocoded = (point) => {\r\n        for (let geocodedPoint of geocodedPoints) {\r\n            if (geocodedPoint.index === point.index) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    const geocodeNewPoint = async (point) => {\r\n        let geocodedPoint = await geocode(point.lat, point.lng);\r\n        await setGeocodedPoints((prevState => {\r\n            let points = prevState.slice();\r\n            points.push({index: point.index, geocodedPoint});\r\n            return points\r\n        }))\r\n    }\r\n\r\n    const geocodeNewPoints = async (points) => {\r\n        for (let point of points) {\r\n            if (!isPointGeocoded(point)) {\r\n                geocodeNewPoint(point)\r\n            }\r\n        }\r\n    }\r\n\r\n    const deleteGeocodePointByIndex = async (index) => {\r\n        await setGeocodedPoints(prevState => {\r\n            let points = prevState.slice();\r\n            points.splice(index, 1);\r\n            return points;\r\n        })\r\n    }\r\n\r\n    const deleteGeocodedPoint = (points) => {\r\n        let isPointDeleted;\r\n        for (let i = 0; i < geocodedPoints.length; i++) {\r\n            isPointDeleted = true;\r\n            for (let point of points) {\r\n                if (geocodedPoints[i].index === point.index) {\r\n                    isPointDeleted = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (isPointDeleted) {\r\n                deleteGeocodePointByIndex(i);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    const geocode = async (lat, lng) => {\r\n        try {\r\n            let response = await fetch(`https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lng}&language=en&key=${API_KEY}`)\r\n            response = await response.json();\r\n            return response.results[0].formatted_address;\r\n        } catch (e) {\r\n            console.error(\"Cannot geocode\")\r\n            return \"Unrecognized place\";\r\n        }\r\n    }\r\n\r\n    useEffect(() => {\r\n        if (props.items.length > geocodedPoints.length) {\r\n            geocodeNewPoints(props.items)\r\n        } else if (props.items.length < geocodedPoints.length) {\r\n            deleteGeocodedPoint(props.items);\r\n        }\r\n        updateDistance(props.items)\r\n    }, [props.items.length])\r\n\r\n    return (\r\n        <List className={classes.root}>\r\n            <div align={\"center\"}>\r\n                <h3>{props.listName + `  [${distance.toFixed(3)} km]`}</h3>\r\n            </div>\r\n            {geocodedPoints.sort(pointsComparator).map((point, key) => {\r\n                return (\r\n                    <ListItem\r\n                        align={\"left\"}\r\n                        primaryText={`[${key + 1}] ${point.geocodedPoint}`}\r\n                        key={key}\r\n                        onClick={() => handleRowClick(point)}\r\n                    />\r\n                );\r\n            })}\r\n        </List>\r\n    );\r\n}\r\n"]},"metadata":{},"sourceType":"module"}